<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Geometry of College Fight Songs</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-contour.v4.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="icon" type="image/png" href="/logos/favicon/bucky.png">
    
    <style>
        :root {
            --bg-color: #050b14; 
            --card-bg: #0b1626;
            --text-color: #ffffff;
            --highlight: #00f2ff; /* Cyan */
            --accent: #ff00ff; /* Pink */
            --dim: #4a5d75;
            --border: 1px solid rgba(0, 242, 255, 0.2);
            --grey-dim: #3a3a3a;
        }

        * {
            box-sizing: border-box;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 10px;
            height: 100vh;
            display: grid;
            /* Ratio: 3.5 (Top) : 2 (Strip) : 3.5 (Bottom) */
            grid-template-rows: 3.5fr 2fr 3.5fr; 
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            overflow: hidden; 
        }

        /* --- Grid Areas --- */
        #viz1 { grid-column: 1 / 2; grid-row: 1 / 2; } 
        #viz4 { grid-column: 2 / 3; grid-row: 1 / 2; } 
        #middle-strip { grid-column: 1 / 3; grid-row: 2 / 3; }
        #viz3 { grid-column: 1 / 2; grid-row: 3 / 4; } 
        #viz2 { grid-column: 2 / 3; grid-row: 3 / 4; } 

        /* --- Containers --- */
        .viz-container {
            background: var(--card-bg);
            border-radius: 6px;
            padding: 10px;
            border: var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            min-height: 0;
            overflow: hidden;
        }

        h3 { 
            margin: 0 0 5px 0; 
            color: var(--highlight); 
            font-weight: 600; 
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--dim);
            padding-bottom: 5px;
            display: flex; justify-content: space-between;
            flex-shrink: 0;
        }
        
        .chart-area { flex-grow: 1; position: relative; overflow: hidden; width: 100%; height: 100%; }

        /* --- Middle Strip --- */
        #middle-strip {
            display: grid;
            grid-template-columns: 1fr 2fr;
            background: #08101c;
            border-top: 2px solid var(--highlight);
            border-bottom: 2px solid var(--highlight);
            overflow: hidden;
            min-height: 0; 
        }

        #strip-left {
            padding: 0 30px;
            border-right: 1px solid var(--dim);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start;
        }
        .sub-top { font-size: 0.8em; color: #888; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px; }
        
        .main-title { 
            font-size: clamp(0.8rem, 2.5vw, 2.2em); 
            color: var(--highlight); 
            font-weight: 800; 
            line-height: 1.0; 
            margin: 0; 
            text-transform: uppercase; 
            white-space: normal; 
            overflow-wrap: break-word;
        }
        
        .sub-bot { font-size: 1em; color: #fff; margin-top: 5px; font-weight: 300; display: flex; align-items: center; gap: 10px; }
        
        .about-link {
            font-size: 0.7em;
            background: #d100d1; 
            padding: 2px 8px;
            border-radius: 10px;
            cursor: pointer;
            color: #ffffff; 
            text-decoration: none;
            transition: all 0.2s;
            font-weight: 700;
        }
        .about-link:hover { 
            background: var(--highlight); 
            color: #000; 
        }

        /* --- Legend Indicators --- */
        .legend-indicator { pointer-events: none; transition: transform 0.2s ease-out; }
        .legend-indicator path { fill: #fff; stroke: #000; stroke-width: 1px; }
        .legend-indicator text { fill: #fff; font-size: 10px; font-weight: bold; text-anchor: middle; text-shadow: 0 0 3px #000; }

        #strip-right {
            display: flex;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        #placeholder-msg {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: var(--dim);
            font-style: italic;
        }

        #active-content {
            display: none; 
            width: 100%;
            height: 100%;
            display: flex; 
        }

        #song-info-panel {
            flex: 1; 
            padding: clamp(10px, 2vh, 25px) 30px; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start; 
            text-align: left;        
            min-width: 0; 
            gap: clamp(2px, 1.5vh, 10px);
            overflow: hidden; 
        }

        #spotify-panel {
            flex: 1 1 0px; 
            max-width: 450px;
            background: #000;
            border-left: 1px solid var(--dim);
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            box-sizing: border-box;
        }

        iframe { width: 100%; height: 152px; border: none; border-radius: 12px; }

        #si-school { 
            font-size: clamp(1.2rem, 3vw, 2.2em); 
            font-weight: 800; 
            color: #fff; 
            line-height: 1.1; 
            text-shadow: 0 0 10px var(--highlight), 0 0 20px var(--highlight);
        }
        #si-conf { font-size: clamp(0.5em, 1vw, 0.9em); color: #666; font-style: italic; font-weight: 400; margin-left: 10px;}
        #si-title { 
            font-size: clamp(0.9rem, 2vw, 1.3em); 
            color: var(--accent); 
            margin: 0; 
            font-style: italic; 
            line-height: 1.2; 
        }
        
        .badges { 
            display: flex; 
            gap: 10px; 
            margin: 0; 
            flex-wrap: wrap; 
            justify-content: flex-start; 
        }
        .badge { background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px; font-size: 0.8em; color: #ccc; display: flex; align-items: center; gap: 5px; }
        .badge i { color: var(--highlight); }

        /* --- Viz 4 Specific Styles --- */
        .network-logo {
            filter: grayscale(100%) drop-shadow(0 0 1px rgba(255,255,255,0.5));
            transition: all 0.2s;
            pointer-events: none; 
        }
        
        .node-group image {
            z-index: 999;
        }

        .stats-row { 
            display: flex; 
            gap: 20px; 
            font-size: 0.9em; 
            color: #aaa; 
            justify-content: flex-start; 
            margin: 0; 
            white-space: nowrap; 
        }
        .stats-row b { color: #fff; }

        /* --- Viz Elements --- */
        .node circle { stroke: #fff; stroke-width: 1px; cursor: pointer; transition: all 0.2s; }
        
        /* Highlight States */
        /* 1. Standard Dim */
        .dimmed { 
            fill: #222 !important; 
            opacity: 0.3 !important; 
            stroke: #333 !important; 
        }
        
        /* 2. Soft Dim */
        .dimmed-soft {
            opacity: 0.3 !important;
            stroke: none !important;
        }

        .neighbor {
            fill: #aaa !important; 
            stroke: #fff !important; 
            stroke-width: 2px !important;
            opacity: 1 !important;
        }
        
        line { transition: all 0.3s; }
        
        .highlighted { 
            fill: var(--accent) !important; 
            stroke: #fff !important; 
            stroke-width: 3px !important; 
            opacity: 1 !important; 
            filter: drop-shadow(0 0 8px var(--accent)) !important;
        }
        
        /* --- FIX: Black outline for highlighted nodes in Viz 4 --- */
        .node-group circle.highlighted {
            stroke: #000 !important;
        }
        
        .logo-dimmed { opacity: 0.3; filter: grayscale(100%); } 
        .logo-highlighted { filter: drop-shadow(0 0 8px var(--highlight)); transform: scale(1.1); opacity: 1; z-index: 10; }

        /* Rect Highlight */
        rect { transition: fill 0.2s; }
        rect.highlighted { fill: var(--accent) !important; opacity: 1 !important; stroke: none !important; }
        rect.dimmed { fill: var(--grey-dim) !important; opacity: 0.5 !important; }

        /* Logos */
        .school-logo { cursor: pointer; transition: transform 0.2s; }
        .school-logo:hover { transform: scale(1.2); z-index: 100; filter: drop-shadow(0 0 5px white); }

        /* UpSet Dots */
        .upset-dot { fill: #333; }
        .upset-dot.active { fill: #888; stroke: none; }
        .upset-dot.dimmed { fill: #222 !important; } 

        /* Persistent Tooltip in Topology */
        .topo-tooltip { pointer-events: none; }
        .topo-tooltip rect { fill: rgba(0, 10, 20, 0.9); stroke: var(--highlight); stroke-width: 1px; rx: 4; }
        .topo-tooltip text { fill: #fff; font-size: 10px; font-family: sans-serif; }

        /* General Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(0, 18, 32, 0.95);
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 9999;
            border: 1px solid var(--highlight);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            font-size: 0.9em;
            color: #fff;
            max-width: 250px;
        }
        
        /* Modal */
        #about-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 10px;
            max-width: 900px;
            border: 2px solid var(--highlight);
            color: #fff;
            position: relative;
        }
        .close-btn { position: absolute; top: 10px; right: 15px; cursor: pointer; font-size: 1.5em; color: #888; }
        .close-btn:hover { color: #fff; }

        text { fill: #aaa; font-size: 11px; }
        .axis-label { font-size: 12px; font-weight: bold; fill: #fff; }
        
        a { color: var(--highlight); text-decoration: none; border-bottom: 1px dotted var(--highlight); }
        a:hover { color: #fff; }

        #lyrical-panel { overflow: visible !important; }
        #logo-grid, #logo-grid > div { overflow: visible !important; z-index: 10; }
        #jaccard-web { overflow: visible !important; }
    </style>
</head>
<body>

    <div id="viz1" class="viz-container">
        <h3>Trope-O-Meter <span style="font-size:0.7em; color:#666;">Cliché make-up</span></h3>
        <div class="chart-area" id="lyrical-panel" style="display:flex; height: 100%;">
            <div id="logo-grid" style="flex: 0 0 55%; overflow: hidden; padding-right: 10px;"></div>
            <div id="trope-dashboard" style="flex: 1; border-left: 1px solid #333; padding-left: 10px; display:flex; flex-direction:column; justify-content:center; align-items:center;">
                <div style="color:#666; font-style:italic;"> </div>
            </div>
        </div>
    </div>

    <div id="viz4" class="viz-container">
        <h3>Jaccard Network <span style="font-size:0.7em; color:#666;">Similar Songs by Tropes</span></h3>
        <div class="chart-area" id="jaccard-web"></div>
    </div>

    <div id="middle-strip">
        <div id="strip-left">
            <div class="sub-top">Bucky's Data Viz Challenge 2026</div>
            <div class="main-title">The Geometry of College Fight Songs</div>
            <div class="sub-bot">
                Barnabás Valkó (UW-Madison)
                <span class="about-link" onclick="document.getElementById('about-modal').style.display='flex'; event.stopPropagation();">ABOUT THIS PAGE</span>
            </div>
        </div>

        <div id="strip-right">
            <div id="placeholder-msg">Select a school fight song to analyze <br>by clicking a node or logo</div>
            
            <div id="active-content" style="display: none;">
                <div id="song-info-panel">
                    <div>
                        <span id="si-school"></span><span id="si-conf"></span>
                    </div>
                    <div id="si-title"></div>
                    
                    <div class="badges" id="si-badges"></div>
                    
                    <div class="stats-row">
                        <span>Year: <b id="si-year"></b></span>
                        <span>Writer(s): <b id="si-writers"></b></span>
                    </div>
                </div>
                
                <div id="spotify-panel"></div>
            </div>
        </div>
    </div>

    <div id="viz3" class="viz-container">
        <h3>Song Topology <span style="font-size:0.7em; color:#666;">Tempo & Duration</span></h3>
        <div class="chart-area" id="topology-map"></div>
    </div>

    <div id="viz2" class="viz-container">
        <h3>Origin Story<span style="font-size:0.7em; color:#666;">Metadata PowerSet</span></h3>
        <div class="chart-area" id="upset-origin"></div>
    </div>

    <div id="tooltip" class="tooltip"></div>
    
   <div id="about-modal" onclick="if(event.target === this) this.style.display='none'">
    <div class="modal-content">
        <span class="close-btn" onclick="document.getElementById('about-modal').style.display='none'">×</span>
        <h2 style="color:var(--highlight); margin-top:0;">ABOUT THIS DASHBOARD</h2>
        <p>This interactive visualization explores the lyrical and musical patterns of 65 major college fight songs. Click any node or logo to analyze that school's fight song. Best viewed in fullscreen.</p>
        <ul>
            <li><strong style="color:var(--highlight)">Trope-O-Meter:</strong> Do the words "fight," "victory," "win" or "won," or "rah" show up?
            Does the song have nonsense syllables, mention any colors, groups of men, or opponents? Is anything spelled?</li>
            <li><strong style="color:var(--highlight)">Jaccard Network:</strong> A network graph connecting songs whose lyrics share at least 75% similarity in tropes. Calculated by Jaccard index.</li>
            <li><strong style="color:var(--highlight)">Song Topology:</strong> A scatter plot of Tempo (BPM) vs. Duration (sec) with added densities. The color indicates how many times the word "fight" is sung.</li>
            <li><strong style="color:var(--highlight)">Origin Story:</strong> An UpSet plot showing how songs were created (Student Author, Contest Winner, or Official Song).</li>
        </ul>
        
        <p><strong>Data Sources:</strong></p>
        <ul style="font-size:0.9em; color:#ccc;">
            <li><a href="https://github.com/fivethirtyeight/data/blob/master/fight-songs/fight-songs.csv" target="_blank">FiveThirtyEight Fight Songs Dataset</a></li>
            <li><a href="https://btaa.org/docs/default-source/research-data/readme-data-description.pdf?sfvrsn=f13148d3_1" target="_blank">BTAA Data Description (PDF)</a></li>
        </ul>

        <p style="font-size:0.9em; color:#888; margin-top:20px;">
            Built with D3.js by Barnabás Valkó (UW-Madison Math/Stats 2027).
            GitHub: <a href="https://github.com/valkobarnabas" target="_blank">valkobarnabas</a>
        </p>
        <p style="font-size:0.66em; color:#555; margin-top:15px; border-top:1px solid #333; padding-top:10px;">
            Logos and songs are copyright their respective universities.
        </p>
    </div>
</div>

<script>
    // --- Utils ---
    const getSlug = (name) => name.toLowerCase().replace(/ /g, "_").replace(/[^a-z0-9_]/g, "");

    // --- Config ---
    const icons = {
        'fight': '\uf6de', 'victory': '\uf25b', 'win_won': '\uf5a2', 
        'rah': '\uf0a1', 'nonsense': '\uf118', 'colors': '\uf53f', 
        'men': '\uf183', 'opponents': '\uf21e', 'spelling': '\uf15d',
        'student_writer': '\uf19d', 'official_song': '\uf058', 'contest': '\uf091'
    };
    
    const iconLabels = {
        'fight': 'Fight', 'victory': 'Victory', 'win_won': 'Win/Won', 
        'rah': 'Rah', 'nonsense': 'Nonsense', 'colors': 'Colors', 
        'men': 'Men', 'opponents': 'Opponents', 'spelling': 'Spelling',
        'student_writer': 'Student Author', 'official_song': 'Official Song', 'contest': 'Contest Winner'
    };
    
    const row1 = ['fight', 'victory', 'win_won', 'rah'];
    const row2 = ['nonsense', 'colors', 'men', 'opponents', 'spelling'];

    // Scales
    const fightColorScale = d3.scaleLinear()
        .domain([0, 5, 10])
        .range(["#8B0000", "#FF4500", "#FFFF00"])
        .clamp(true);

    const tropeColorScale = d3.scaleLinear()
        .domain([0, 8])
        .range(["#000055", "#00ff00"]);

    let showTopologyTooltip = null; // Global reference
    let drawViz4 = null; // Global reference

    // Global state for navigation
    let sortedData = [];
    let currentIndex = -1; 

    d3.csv("fight-songs.csv").then(data => {
        data = data.filter(d => d.school && d.school.trim() !== "");
        data.forEach(d => {
            for(let key in d) { if(typeof d[key] === 'string') d[key] = d[key].trim(); }
            d.bpm = +d.bpm;
            d.sec_duration = +d.sec_duration;
            d.number_fights = +d.number_fights;
            d.trope_count = +d.trope_count;
            d.id = d.school;
            d.isCenter = false; 
        });

        // Sort data alphabetically once for consistent navigation
        sortedData = [...data].sort((a,b) => d3.ascending(a.school, b.school));

        const tooltip = d3.select("#tooltip");

        // --- GLOBAL RESET ---
        d3.selectAll(".chart-area").on("click", function(e) {
            if(e.target === this || e.target.tagName === 'svg') updateSelection(null);
        });

       function updateSelection(schoolName) {
            // FORCE TOOLTIP HIDE ON UPDATE
            d3.select("#tooltip").style("opacity", 0);

            if (!schoolName) {
                currentIndex = -1; 
                
                // Reset Visuals
                d3.selectAll(".dimmed").classed("dimmed", false);
                d3.selectAll(".dimmed-soft").classed("dimmed-soft", false);
                d3.selectAll(".neighbor").classed("neighbor", false);
                d3.selectAll(".highlighted").classed("highlighted", false);
                d3.selectAll(".logo-dimmed").classed("logo-dimmed", false);
                d3.selectAll(".logo-highlighted").classed("logo-highlighted", false);
                
                // Reset Links (Hide them)
                d3.selectAll(".network-link").style("opacity", 0); 

                d3.selectAll("rect").classed("highlighted", false).classed("dimmed", false).attr("fill", "#444");
                d3.selectAll(".upset-dot").classed("dimmed", false).style("fill", function() { return d3.select(this).classed("active") ? "#888" : "#333"; });

                d3.select("#placeholder-msg").style("display", "flex");
                d3.select("#active-content").style("display", "none");
                d3.select("#si-logo").style("display", "none");
                d3.select("#spotify-panel").html("");
                
                drawTropeDashboard(null);
                if(showTopologyTooltip) showTopologyTooltip(null);
                
                // Reset Indicators
                d3.selectAll(".legend-indicator").style("display", "none");

                // Reset "No Fights" Legend
                const nf = d3.select("#no-fights-group");
                nf.style("opacity", 0.5); // Back to default opacity
                d3.select("#no-fights-check").style("display", "none"); // Hide check
                
                // --- VIZ 4 RESET: Show Grid with Tiny Text ---
                drawViz4(null);

                return;
            }

            currentIndex = sortedData.findIndex(d => d.school === schoolName);
            const d = data.find(r => r.school === schoolName);

            // 1. Viz 1 (Standard Dim)
            d3.selectAll(".school-logo").classed("logo-dimmed", true).classed("logo-highlighted", false);
            
            // 2. Viz 2 (Data Bars Only)
            d3.selectAll(".upset-row rect").classed("dimmed", true).classed("highlighted", false);
            
            // 3. Viz 3 (Soft Dim - Keep Colors)
            d3.selectAll(".scatter-node").classed("dimmed-soft", true).classed("highlighted", false);

            // 4. Highlight Logo (Viz 1)
            d3.selectAll(`.school-logo[data-school="${schoolName}"]`).classed("logo-dimmed", false).classed("logo-highlighted", true);

            // 5. Highlight Origin Bars (Viz 2)
            d3.selectAll("#upset-origin rect").each(function() {
                const schools = JSON.parse(d3.select(this).attr("data-schools") || "[]");
                if (schools.includes(schoolName)) {
                    d3.select(this).classed("dimmed", false).classed("highlighted", true); 
                    d3.select(this.parentNode).selectAll(".upset-dot.active").classed("dimmed", false).style("fill", "#ff00ff");
                }
            });
            d3.selectAll("rect.dimmed").each(function() {
                 d3.select(this.parentNode).selectAll(".upset-dot").classed("dimmed", true);
            });
            
            // 6. Highlight Scatter Node (Viz 3)
            d3.selectAll(`.scatter-node[data-school="${schoolName}"]`)
                .classed("dimmed-soft", false)
                .classed("highlighted", true)
                .raise();

            // 7. Update Middle Panel
            d3.select("#placeholder-msg").style("display", "none");
            d3.select("#active-content").style("display", "flex");

            d3.select("#si-logo").attr("src", `logos/${getSlug(d.school)}.png`).style("display", "block");
            d3.select("#si-school").text(d.school);
            d3.select("#si-conf").text(`(${d.conference})`);
            d3.select("#si-title").text(`"${d.song_name}"`);
            d3.select("#si-year").text(d.year);

            const wSpan = d3.select("#si-writers");
            wSpan.text(d.writers).style("font-size", "1em");
            
            const rowNode = wSpan.node().closest(".stats-row");
            const panelNode = document.getElementById("song-info-panel");
            
            let fs = 1.0;
            while (rowNode.scrollWidth > (panelNode.clientWidth - 40) && fs > 0.5) {
                fs -= 0.05;
                wSpan.style("font-size", `${fs}em`);
            }
            
            let badgesHTML = "";
            if(d.official_song === "Yes") badgesHTML += `<div class="badge"><i class="fas fa-check-circle"></i> Official</div>`;
            if(d.student_writer === "Yes") badgesHTML += `<div class="badge"><i class="fas fa-graduation-cap"></i> Student</div>`;
            if(d.contest === "Yes") badgesHTML += `<div class="badge"><i class="fas fa-trophy"></i> Contest</div>`;
            d3.select("#si-badges").html(badgesHTML);

            if (d.spotify_id) {
                const url = `https://open.spotify.com/embed/track/${d.spotify_id}?utm_source=generator&theme=0`;
                d3.select("#spotify-panel").html(`<iframe src="${url}" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>`);
            } else {
                d3.select("#spotify-panel").html(`<div style="color:#444;">No Audio</div>`);
            }

            drawTropeDashboard(d);
            if(showTopologyTooltip) showTopologyTooltip(d);
            
            // B. Fight Indicator (Viz 3)
            const fInd = d3.select("#fight-indicator");
            const noFightG = d3.select("#no-fights-group");
            const nfCheck = d3.select("#no-fights-check");
            
            if (d.number_fights === 0) {
                 fInd.style("display", "none");
                 noFightG.style("opacity", 1); 
                 nfCheck.style("display", "block"); 
            } else {
                noFightG.style("opacity", 0.3); 
                nfCheck.style("display", "none"); 

                fInd.style("display", "block");
                const scale = d3.scaleLinear().domain([1, 10]).range([0, 70]).clamp(true);
                const xPos = scale(d.number_fights);
                
                fInd.attr("transform", `translate(${xPos}, 0)`);
                fInd.select("text").text(d.number_fights);
            }

            // --- VIZ 4 UPDATE: Radial Layout ---
            drawViz4(d);

            // --- VIZ 4 LEGEND INDICATOR (MUST BE CALLED AFTER DRAWVIZ4) ---
             const tInd = d3.select("#trope-indicator");
            if (tInd.node()) {
                tInd.style("display", "block");
                const legDivW = d3.select("#jaccard-web > div:nth-child(2)").node().getBoundingClientRect().width;
                const barWidth = legDivW - 30;
                const scale = d3.scaleLinear().domain([0, 8]).range([0, barWidth]);
                const xPos = scale(d.trope_count);
                
                // Position group horizontally. Vertical pos is handled inside drawViz4 via path/text attrs.
                tInd.attr("transform", `translate(${xPos}, 0)`); 
                tInd.select("text").text(d.trope_count);
            }
        }
        
    
        // --- GLOBAL RESET HANDLER ---
        d3.select("body").on("click", function(e) {
            if (e.target.closest(".modal-content")) return;
            if (e.target.closest(".about-link")) return;
            if (e.target.closest("iframe")) return;
            updateSelection(null);
        });
        
function drawTropeDashboard(d) {
    const container = d3.select("#trope-dashboard");
    container.html(""); 

    const rect = container.node().getBoundingClientRect();
    const size = Math.max(10, Math.min(22, rect.width / 16)); 

    const wrapper = container.append("div")
        .style("display", "flex").style("flex-direction", "column").style("gap", "20px").style("width", "100%");

    const createRow = (keys) => {
        const rowDiv = wrapper.append("div")
            .style("display", "flex").style("justify-content", "space-around").style("width", "100%");
        
        keys.forEach(key => {
            const hasTrope = d ? (d[key] === 'Yes') : false;
            const cell = rowDiv.append("div")
                .style("display", "flex").style("flex-direction", "column").style("align-items", "center")
                .style("opacity", hasTrope ? 1 : 0.2);

            cell.append("div")
                .style("font-family", "FontAwesome")
                .style("font-size", size + "px") 
                .style("color", "#00f2ff").style("margin-bottom", "5px")
                .text(icons[key]);
            
            cell.append("div")
                .style("font-size", (size * 0.45) + "px") 
                .style("color", "#aaa").style("margin-bottom", "5px")
                .text(iconLabels[key]);

            const circle = cell.append("div")
                .style("width", size + "px").style("height", size + "px") 
                .style("border-radius", "50%")
                .style("border", "2px solid " + (hasTrope ? "#00f2ff" : "#444"))
                .style("background", hasTrope ? "rgba(0, 242, 255, 0.2)" : "transparent")
                .style("display", "flex").style("align-items", "center").style("justify-content", "center")
                .style("font-size", (size * 0.5) + "px").style("color", "#fff").style("font-weight", "bold");

            if (key === 'fight' && hasTrope) circle.text(d.number_fights);
        });
    };
    createRow(row1); createRow(row2); 
}

    
        // --- VIZ 1: Grid (11x6) ---
        function initViz1() {
            const gridDiv = d3.select("#logo-grid");
            gridDiv.html("");
            
            const container = gridDiv.append("div")
                .style("display", "grid")
                .style("grid-template-columns", "repeat(11, 1fr)")
                .style("grid-template-rows", "repeat(6, 1fr)")
                .style("width", "100%")
                .style("height", "100%")
                .style("gap", "2px");

            const sortedData = [...data].sort((a,b) => d3.ascending(a.school, b.school));

            container.selectAll("div")
                .data(sortedData)
                .enter().append("div")
                .style("display", "flex").style("align-items", "center").style("justify-content", "center")
                .append("img")
                .attr("src", d => `logos/${getSlug(d.school)}.png`)
                .style("max-width", "100%").style("max-height", "100%").style("object-fit", "contain")
                .attr("class", "school-logo")
                .attr("data-school", d => d.school)
                .attr("title", d => d.school)
                .on("click", (e, d) => { e.stopPropagation(); updateSelection(d.school); })
                .on("error", function() { this.style.display='none'; });
            drawTropeDashboard(null);
        }
        
        initViz1();


       // --- VIZ 4: Trope Network ---
        drawViz4 = (focusNode) => {
            // FIX: RESET CENTER FLAGS
            data.forEach(n => n.isCenter = false);

            const container = d3.select("#jaccard-web");
            container.html(""); 

            container.style("display", "flex").style("height", "100%").style("width", "100%");

            const chartDiv = container.append("div")
                .style("flex", "4")
                .style("position", "relative")
                .style("height", "100%");

            const legendDiv = container.append("div")
                .style("flex", "1")
                .style("background", "rgba(0,0,0,0.2)") 
                .style("border-left", "1px solid #333")
                .style("height", "100%");

            const rect = chartDiv.node().getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const svg = chartDiv.append("svg").attr("width", w).attr("height", h).style("overflow", "visible");
            const g = svg.append("g");

            // --- Sorting Logic ---
            let sortedNodes = [...data].sort((a,b) => {
                if (b.trope_count !== a.trope_count) return b.trope_count - a.trope_count;
                if (a.year !== b.year) return a.year - b.year; 
                return a.school.localeCompare(b.school);
            });

            // --- CALCULATE NEIGHBORS ---
            const links = [];
            const t = ['victory','win_won','rah','nonsense','colors','men','opponents','spelling'];
            const nodeMap = {}; sortedNodes.forEach(d=>nodeMap[d.id]=d);

            for(let i=0; i<sortedNodes.length; i++) {
                for(let j=i+1; j<sortedNodes.length; j++) {
                    const n1 = sortedNodes[i];
                    const n2 = sortedNodes[j];
                    let union = 0, intersect = 0;
                    t.forEach(k => { 
                        const a = n1[k]==='Yes'; const b = n2[k]==='Yes';
                        if(a||b) union++; if(a&&b) intersect++; 
                    });
                    
                    const sim = union === 0 ? 0 : intersect/union;

                    if(sim > 0.74) {
                        links.push({ source: n1.school, target: n2.school, similarity: sim });
                    }
                }
            }
            // Manual overrides 
            [["Michigan", "Tennessee"], ["Tennessee", "Boston College"], ["Boston College", "Michigan"]].forEach(pair => {
                if(!links.find(l => (l.source===pair[0] && l.target===pair[1]) || (l.source===pair[1] && l.target===pair[0]))) {
                    links.push({ source: pair[0], target: pair[1], similarity: 1.0 }); 
                }
            });

            // --- LAYOUT LOGIC ---
            let renderNodes = [];
            let renderLinks = [];
            let r = 0;

            if (focusNode) {
                // *** FOCUSED MODE (Radial) ***
                const neighbors = [];
                links.forEach(l => {
                    if (l.source === focusNode.school) neighbors.push(l.target);
                    else if (l.target === focusNode.school) neighbors.push(l.source);
                });
                
                renderNodes = sortedNodes.filter(n => n.school === focusNode.school || neighbors.includes(n.school));
                renderLinks = links.filter(l => (l.source === focusNode.school && neighbors.includes(l.target)) || (l.target === focusNode.school && neighbors.includes(l.source)));
                
                // Base radius
                r = Math.min(w, h) * 0.05; 

                const centerNode = renderNodes.find(n => n.school === focusNode.school);
                centerNode.x = w/2; 
                centerNode.y = h/2;
                centerNode.isCenter = true; 
                
                const neighborNodes = renderNodes.filter(n => n.school !== focusNode.school);
                
                // --- NO NEIGHBORS LOGIC ---
                if(neighborNodes.length === 0) {
                    g.append("text")
                        .attr("x", w/2)
                        .attr("y", h/2 + (r*3) + 25) 
                        .attr("text-anchor", "middle")
                        .style("fill", "#888")
                        .style("font-size", "12px")
                        .style("font-style", "italic")
                        .text("No songs with ≥75% trope similarity");
                }

                const circleRadius = Math.min(w, h) * 0.35;
                const angleStep = (2 * Math.PI) / neighborNodes.length;
                
                neighborNodes.forEach((n, i) => {
                    const angle = i * angleStep - Math.PI/2;
                    n.x = (w/2) + Math.cos(angle) * circleRadius;
                    n.y = (h/2) + Math.sin(angle) * circleRadius;
                });
                
                renderLinks.forEach(l => {
                    const s = renderNodes.find(n => n.school === l.source);
                    const t = renderNodes.find(n => n.school === l.target);
                    if(s && t) { l.x1=s.x; l.y1=s.y; l.x2=t.x; l.y2=t.y; }
                });

            } else {
                // *** DEFAULT MODE (Grid) ***
                renderNodes = sortedNodes;
                const cols = 13;
                const rows = Math.ceil(renderNodes.length / cols);
                const cellW = w / cols;
                const cellH = h / rows;
                r = Math.min(cellW, cellH) * 0.4; 

                renderNodes.forEach((d, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    d.x = (col * cellW) + cellW/2;
                    d.y = (row * cellH) + cellH/2;
                });
            }

            // --- RENDER LINKS (Permanent ones for Focus Mode) ---
            if (focusNode) {
                 g.selectAll("line.link").data(renderLinks).enter().append("line")
                    .attr("class", "link")
                    .attr("x1", d => d.x1).attr("y1", d => d.y1)
                    .attr("x2", d => d.x2).attr("y2", d => d.y2)
                    .attr("stroke", "#ffffff")
                    .attr("stroke-width", d => d.similarity >= 0.99 ? 4 : 1)
                    .attr("opacity", d => d.similarity >= 0.99 ? 1 : 0.6);
            }

            // --- RENDER NODES ---
            const nodeG = g.selectAll(".node-group").data(renderNodes).enter().append("g")
                .attr("class", "node-group")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("click", (e, d) => { e.stopPropagation(); updateSelection(d.school); })
                .on("mouseover", (e, d) => {
                    d3.select(e.currentTarget).raise(); 
                    
                    // --- NEW FEATURE: Show Neighbor Lines ---
                    // 1. Find all links connected to this node
                    const activeLinks = links.filter(l => l.source === d.school || l.target === d.school);
                    
                    // 2. Identify neighbor names
                    const neighborNames = activeLinks.map(l => l.source === d.school ? l.target : l.source);

                    // 3. Find screen positions of neighbors (must be currently visible)
                    const currentNodeMap = {};
                    g.selectAll(".node-group").each(function(nd) {
                        currentNodeMap[nd.school] = { x: nd.x, y: nd.y };
                    });

                    // 4. Calculate coordinates for temporary lines
                    const linesToDraw = activeLinks.map(l => {
                        const targetName = l.source === d.school ? l.target : l.source;
                        const targetPos = currentNodeMap[targetName];
                        if (!targetPos) return null; // Skip if neighbor is not visible (e.g. in radial view)
                        return {
                            x1: d.x, y1: d.y,
                            x2: targetPos.x, y2: targetPos.y,
                            similarity: l.similarity
                        };
                    }).filter(x => x);

                    // 5. Draw the temporary lines (insert before nodes so they are behind)
                    g.selectAll("line.temp-link")
                        .data(linesToDraw)
                        .enter().insert("line", ".node-group")
                        .attr("class", "temp-link")
                        .attr("x1", l => l.x1).attr("y1", l => l.y1)
                        .attr("x2", l => l.x2).attr("y2", l => l.y2)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", l => l.similarity >= 0.99 ? 3 : 1)
                        .attr("opacity", 0.8)
                        .style("pointer-events", "none");

                    // 6. Highlight Neighbor Nodes
                    g.selectAll(".node-group circle")
                        .filter(nd => neighborNames.includes(nd.school))
                        .classed("neighbor", true);
                    // ----------------------------------------

                    d3.select("#tooltip").style("opacity", 1)
                        .html(`<b>${d.school}</b><br>Trope Count: ${d.trope_count}<br>Year: ${d.year}`)
                        .style("left", (e.pageX+10)+"px").style("top", (e.pageY-10)+"px");
                })
                .on("mouseout", () => {
                    // --- CLEANUP ---
                    g.selectAll("line.temp-link").remove();
                    g.selectAll(".neighbor").classed("neighbor", false);
                    
                    d3.select("#tooltip").style("opacity", 0);
                });

            const circle = nodeG.append("circle")
                .attr("r", d => d.isCenter ? r * 3 : r) 
                .attr("fill", d => tropeColorScale(d.trope_count))
                .attr("stroke", "#000").attr("stroke-width", 1) 
                .classed("highlighted", d => focusNode && d.school === focusNode.school);
            
            // --- TEXT LABELS (SONG NAMES) ---
            if (focusNode) {
                // 1. CENTER NODE
                const centerG = nodeG.filter(d => d.school === focusNode.school);
                
                centerG.append("text")
                    .text(d => `"${d.song_name}"`) 
                    .attr("text-anchor", "middle")
                    .attr("dy", "0.35em") 
                    .style("fill", "#fff")
                    .style("font-size", "16px") 
                    .style("font-weight", "800")
                    .style("text-shadow", "0 2px 4px rgba(0,0,0,0.8)"); 

                // 2. NEIGHBORS (DIRECTIONAL LOGIC)
                nodeG.filter(d => d.school !== focusNode.school)
                    .append("text")
                    .text(d => `"${d.song_name}"`)
                    .style("fill", "#fff")
                    .style("font-size", "12px")
                    .style("text-shadow", "0 0 2px #000")
                    .each(function(d) {
                        const sel = d3.select(this);
                        const cy = h/2;
                        const cx = w/2;
                        
                        const isVertical = Math.abs(d.x - cx) < 10;
                        const isHorizontal = Math.abs(d.y - cy) < 10;
                        const isLeft = d.x < cx;
                        const isRight = d.x > cx;
                        const isAbove = d.y < cy;
                        
                        if (isVertical) {
                            sel.attr("text-anchor", "middle").attr("x", 0);
                        } else if (isLeft) {
                            sel.attr("text-anchor", "end").attr("x", r + 4);
                        } else {
                            sel.attr("text-anchor", "start").attr("x", -r - 4);
                        }

                        let goUp = false;
                        if (isHorizontal && isLeft) goUp = true;
                        else if (isHorizontal && isRight) goUp = false;
                        else if (isAbove) goUp = true;
                        else goUp = false;

                        if (goUp) {
                            sel.attr("y", -r - 5).attr("dominant-baseline", "auto"); 
                        } else {
                            sel.attr("y", r + 5).attr("dominant-baseline", "hanging");
                        }
                    });

            } else {
                // *** DEFAULT GRID MODE ***
                const specialSchools = ["Wake Forest", "Stanford", "Florida", "Georgia Tech", "Rutgers", "Virginia", "Northwestern", "Washington", "Maryland", "Ohio State", "Miami", "Indiana", "Nebraska", "North Carolina", "North Carolina State"];
                const superSpecial = ["South Carolina"];

                nodeG.append("text")
                    .style("font-size", d => {
                        if (superSpecial.includes(d.school)) return r * 0.3 + "px";
                        if (specialSchools.includes(d.school)) return r * 0.3 + "px";
                        return r * 0.4 + "px";
                    })
                    .style("fill", "#fff")
                    .style("text-anchor", "middle")
                    .style("pointer-events", "none")
                    .style("text-shadow", "0 0 2px #000")
                    .each(function(d) {
                        const words = d.song_name.replace(/-/g, "- ").split(/\s+/);
                        let maxLines = 3;
                        let fontSize = r * 0.4;
                        if (superSpecial.includes(d.school)) { maxLines = 5; fontSize = r * 0.3; } 
                        else if (specialSchools.includes(d.school)) { maxLines = 4; fontSize = r * 0.3; }
                        
                        const charW = fontSize * 0.6; 
                        let lines = [];
                        let currentLine = [];
                        
                        for (let w of words) {
                            let potentialLine = currentLine.concat(w).join(" ");
                            if (potentialLine.length * charW < (r * 1.8)) {
                                currentLine.push(w);
                            } else {
                                if (currentLine.length > 0) lines.push(currentLine.join(" "));
                                currentLine = [w];
                            }
                        }
                        if(currentLine.length > 0) lines.push(currentLine.join(" "));
                        if(lines.length > maxLines) lines = lines.slice(0, maxLines);
                        
                        const lineHeightEm = 1.1; 
                        const startDy = -((lines.length - 1) * lineHeightEm / 2);

                        d3.select(this).selectAll("tspan")
                            .data(lines)
                            .enter().append("tspan")
                            .text(l => l.trim())
                            .attr("x", 0)
                            .attr("dy", (l, i) => i === 0 ? startDy + "em" : lineHeightEm + "em");
                    });
            }

            // --- LEGEND ---
            const lRect = legendDiv.node().getBoundingClientRect();
            const legW = lRect.width;
            const legH = lRect.height;
            const legSvg = legendDiv.append("svg").attr("width", legW).attr("height", legH);
            const baseFS = Math.max(9, Math.min(13, legW / 10)); 
            const smallFS = Math.max(8, Math.min(11, legW / 12));
            const defs = legSvg.append("defs");
            const linearGradient = defs.append("linearGradient").attr("id", "trope-gradient");
            linearGradient.append("stop").attr("offset", "0%").attr("stop-color", "#000055");
            linearGradient.append("stop").attr("offset", "100%").attr("stop-color", "#00ff00");
            const legG = legSvg.append("g").attr("transform", "translate(15, 20)");

            legG.append("text").text("TROPE COUNT").attr("fill", "#00f2ff").attr("font-size", baseFS + "px").attr("font-weight", "bold");
            const barWidth = legW - 30;
            const barY = 30; 
            
            legG.append("rect").attr("y", barY).attr("width", barWidth).attr("height", 12).style("fill", "url(#trope-gradient)").style("stroke", "#444");
            legG.append("text").text("0").attr("y", barY + 25).attr("x", 0).attr("fill", "#aaa").attr("font-size", smallFS + "px");
            legG.append("text").text("8").attr("y", barY + 25).attr("x", barWidth).attr("text-anchor", "end").attr("fill", "#aaa").attr("font-size", smallFS + "px");

            const tropeInd = legG.append("g").attr("id", "trope-indicator").attr("class", "legend-indicator").style("display", "none"); 
            tropeInd.append("path").attr("d", "M -4 -6 L 4 -6 L 0 0 Z").attr("transform", `translate(0, ${barY})`); 
            tropeInd.append("text").attr("y", barY - 8).text("0");

            const sectionConnY = 80; 
            legG.append("text").text("CONNECTIONS").attr("y", sectionConnY + 5).attr("fill", "#00f2ff").attr("font-size", baseFS + "px").attr("font-weight", "bold");
            
            const exG = legG.append("g").attr("transform", `translate(0, ${sectionConnY + 20})`);
            
            // Standard Link
            exG.append("line").attr("x1", 0).attr("y1", 0).attr("x2", 30).attr("y2", 0).attr("stroke", "#aaa").attr("stroke-width", 1);
            exG.append("text").attr("x", 35).attr("y", 3).text("≥75% Match").style("fill", "#aaa").style("font-size", smallFS+"px");

            // Bold Link
            exG.append("line").attr("x1", 0).attr("y1", 20).attr("x2", 30).attr("y2", 20).attr("stroke", "#fff").attr("stroke-width", 4);
            exG.append("text").attr("x", 35).attr("y", 23).text("100% Match").style("fill", "#fff").style("font-size", smallFS+"px");

            legG.append("foreignObject")
                .attr("x", 0)
                .attr("y", sectionConnY + 60)
                .attr("width", legW - 10)
                .attr("height", 100)
                .append("xhtml:div")
                .style("font-size", smallFS + "px") 
                .style("color", "#ccc")
                .style("line-height", "1.2")
                .style("width", "100%") 
                .html("Click a node to reveal connections to songs with similar tropes.");

            svg.on("click", (e) => { if(e.target === svg.node()) updateSelection(null); });
            legSvg.on("click", (e) => { if(e.target === legSvg.node()) updateSelection(null); });
            }
        drawViz4(null); 


        // --- VIZ 3: Topology ---
        const drawViz3 = () => {
            const container = document.getElementById('topology-map');
            d3.select("#topology-map").html("");
            
            const w = container.clientWidth;
            const h = container.clientHeight;
            const svg = d3.select("#topology-map").append("svg").attr("width", w).attr("height", h);
            
            const margin = {top: 10, right: 110, bottom: 30, left: 40};
            const iw = w - margin.left - margin.right;
            const ih = h - margin.top - margin.bottom;

            const x = d3.scaleLinear().domain([0, 180]).range([0, iw]);
            const y = d3.scaleLinear().domain([60, 190]).range([ih, 0]);

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            // Density
            const contours = d3.contourDensity().x(d=>x(d.sec_duration)).y(d=>y(d.bpm))
                .size([iw, ih]).bandwidth(15)(data);
            g.append("g").selectAll("path").data(contours).enter().append("path")
                .attr("d", d3.geoPath()).attr("fill", "#00f2ff").attr("opacity", 0.08);

            // Axes
            g.append("g").attr("transform", `translate(0,${ih})`).call(d3.axisBottom(x).ticks(5));
            g.append("g").call(d3.axisLeft(y).ticks(5));
            g.selectAll(".domain, .tick line").attr("stroke", "#444");
            g.append("text").attr("class", "axis-label").attr("x", iw).attr("y", ih - 5).attr("text-anchor", "end").text("Duration (sec)");
            g.append("text").attr("class", "axis-label").attr("x", 10).attr("y", 15).text("BPM");

            // Dots (Added class scatter-node)
            g.selectAll("circle").data(data).enter().append("circle")
                .attr("class", "scatter-node")
                .attr("cx", d => x(d.sec_duration))
                .attr("cy", d => y(d.bpm))
                .attr("r", 6)
                .attr("fill", d => d.number_fights === 0 ? "#666" : fightColorScale(d.number_fights))
                .attr("stroke", "#000")
                .attr("data-school", d => d.school)
                .on("mouseover", (e, d) => {
                     d3.select(e.currentTarget).raise();
                     if(showTopologyTooltip) showTopologyTooltip(d);
                })
                .on("click", (e, d) => { e.stopPropagation(); updateSelection(d.school); });

            // Persistent Tooltip Definition
            const pTip = g.append("g").attr("class", "topo-tooltip").style("display", "none");
            pTip.append("rect").attr("width", 110).attr("height", 55).attr("x", 10).attr("y", -30).attr("fill", "rgba(0,0,0,0.9)").attr("stroke", "#00f2ff");
            const tText = pTip.append("text").attr("x", 15).attr("y", -15).style("fill", "#fff").style("font-size", "10px");
            
            tText.append("tspan").attr("id", "pt-school").attr("x", 15).attr("dy", 0).style("font-weight", "bold").style("fill", "#00f2ff");
            tText.append("tspan").attr("id", "pt-bpm").attr("x", 15).attr("dy", 12);
            tText.append("tspan").attr("id", "pt-dur").attr("x", 15).attr("dy", 12);
            tText.append("tspan").attr("id", "pt-fight").attr("x", 15).attr("dy", 12);

            showTopologyTooltip = function(d) {
                if(!d) {
                    pTip.style("display", "none");
                } else {
                    const cx = x(d.sec_duration);
                    const cy = y(d.bpm);
                    pTip.style("display", "block").attr("transform", `translate(${cx}, ${cy})`).raise();
                    pTip.select("#pt-school").text(d.school);
                    pTip.select("#pt-bpm").text(`BPM: ${d.bpm}`);
                    pTip.select("#pt-dur").text(`Duration: ${d.sec_duration}s`);
                    pTip.select("#pt-fight").text(`"Fight"s: ${d.number_fights}`);
                }
            };

            // Key
            const isSmall = w < 400;
            const legScale = isSmall ? 0.7 : 1; 
            const legX = w - (isSmall ? 70 : 100);

            const leg = svg.append("g")
                .attr("transform", `translate(${legX}, 20) scale(${legScale})`);
            
            leg.append("text").text(`# of "Fight"s`).attr("y", 0).style("font-size","9px").style("fill","#FF4500");
            
            const grad = svg.append("defs").append("linearGradient").attr("id", "gradFight");
            grad.append("stop").attr("offset", "0%").style("stop-color", "#8B0000");
            grad.append("stop").attr("offset", "50%").style("stop-color", "#FF4500");
            grad.append("stop").attr("offset", "100%").style("stop-color", "#FFFF00");
            
            leg.append("rect").attr("class", "legend-rect").attr("y", 25).attr("width", 70).attr("height", 8).style("fill", "url(#gradFight)");
            leg.append("text").text("1").attr("y", 45).attr("x", 0); 
            leg.append("text").text("5").attr("y", 45).attr("x", 32);
            leg.append("text").text("10+").attr("y", 45).attr("x", 65);

            const fightInd = leg.append("g")
                .attr("id", "fight-indicator")
                .attr("class", "legend-indicator")
                .style("display", "none");
            
            fightInd.append("path").attr("d", "M -4 -6 L 4 -6 L 0 0 Z").attr("transform", "translate(0, 25)");
            fightInd.append("text").attr("y", 15).text("0");

            const noFightsG = leg.append("g")
                .attr("id", "no-fights-group") 
                .style("opacity", 0.5); 
            
            noFightsG.append("rect").attr("class", "legend-rect").attr("x", 0).attr("y", 55).attr("width", 12).attr("height", 12).attr("fill", "#666").attr("stroke", "#000");
            noFightsG.append("path").attr("id", "no-fights-check").attr("d", "M 2 6 L 5 9 L 10 2").attr("transform", "translate(1, 56)").attr("fill", "none").attr("stroke", "#fff").attr("stroke-width", 2).style("display", "none");
            noFightsG.append("text").text(`No "Fight"s`).attr("x", 18).attr("y", 65).style("font-size", "9px").style("fill", "#ccc");
            
            svg.on("click", (e) => { if(e.target === svg.node()) updateSelection(null); });
        };
        drawViz3();


        // --- VIZ 2: Origin Story ---
        const drawViz2 = () => {
            d3.select("#upset-origin").html("");
            const container = document.getElementById('upset-origin');
            const w = container.clientWidth;
            const h = container.clientHeight;
            const svg = d3.select("#upset-origin").append("svg").attr("width", w).attr("height", h);

            const meta = ['official_song', 'student_writer', 'contest'];
            const combos = {};
            const totals = { 'official_song': 0, 'student_writer': 0, 'contest': 0 };

            data.forEach(d => {
                const sig = meta.map(t => {
                    if (d[t] === 'Yes') { totals[t]++; return '1'; }
                    return '0';
                }).join("");
                if (!combos[sig]) combos[sig] = { count: 0, sig: sig, schools: [] };
                combos[sig].count++;
                combos[sig].schools.push(d.school);
            });
            const sorted = Object.values(combos).sort((a,b) => b.count - a.count);

            const margin = {top: 65, right: 10, bottom: 5, left: 10};
            const rowH = (h - margin.top - margin.bottom) / sorted.length;
            const matrixWidth = w * 0.4; 
            const barAreaWidth = w * 0.6;
            const maxVal = d3.max(sorted, d=>d.count);
            const barScale = d3.scaleLinear().domain([0, maxVal]).range([0, barAreaWidth - 40]);

            const g = svg.append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
            
            g.append("text").attr("x", barAreaWidth - 10).attr("y", -10).attr("text-anchor", "end")
             .style("fill", "#888").style("font-size", "10px").text("Number of Songs (65)");

            const headerG = svg.append("g").attr("transform", `translate(${margin.left + barAreaWidth}, ${margin.top - 10})`);
            const colW = matrixWidth / meta.length;
            
            meta.forEach((m, i) => {
                const centerX = i * colW + colW/2;
                
                // 1. Icon 
                headerG.append("text").attr("x", centerX).attr("y", -38).attr("text-anchor", "middle")
                    .style("font-family", "FontAwesome").style("font-size", "14px").style("fill", "#ff00ff").text(icons[m]);
                
                // 2. Count 
                headerG.append("text").attr("x", centerX).attr("y", -1).attr("text-anchor", "middle")
                    .style("font-size", "9px").style("fill", "#bbb").style("font-weight", "bold").text(`(${totals[m]})`);

                // 3. Label 
                const labelWords = iconLabels[m].split(" ");
                labelWords.forEach((word, idx) => {
                    headerG.append("text").attr("x", centerX).attr("y", -22 + (idx*9)).attr("text-anchor", "middle")
                        .style("font-size", "9px").style("fill", "#fff").text(word);
                });
            });

            sorted.forEach((d, i) => {
                const y = i * rowH;
                const centerY = y + rowH/2;
                const rowG = g.append("g").attr("class", "upset-row");

                rowG.append("rect")
                    .attr("x", barAreaWidth - barScale(d.count) - 10)
                    .attr("y", centerY - 8).attr("width", barScale(d.count)).attr("height", 16)
                    .attr("fill", "#444") 
                    .attr("data-schools", JSON.stringify(d.schools))
                    .on("mouseover", function(e) { 
                         if(!d3.select(this).classed("highlighted")) d3.select(this).attr("fill", "#888");
                         const names = d.schools.slice(0, 10).join(", ") + (d.schools.length > 10 ? "..." : "");
                         tooltip.style("opacity", 1).html(`<b>${d.count} Schools</b><br>${names}`)
                                .style("left", (e.pageX+10)+"px").style("top", (e.pageY-10)+"px");
                    })
                    .on("mouseout", function() { 
                        if(!d3.select(this).classed("highlighted")) d3.select(this).attr("fill", "#444"); 
                        tooltip.style("opacity", 0);
                    })
                    .on("click", (e) => {
                        e.stopPropagation();
                        if (d.schools.length === 1) updateSelection(d.schools[0]);
                    });
                
                rowG.append("text").attr("x", barAreaWidth - barScale(d.count) - 15).attr("y", centerY + 4).attr("text-anchor", "end").text(d.count);
                rowG.append("line").attr("x1", barAreaWidth).attr("x2", w).attr("y1", centerY).attr("y2", centerY).attr("stroke", "#333");
                
                meta.forEach((m, k) => {
                    const active = d.sig[k] === '1';
                    rowG.append("circle").attr("cx", barAreaWidth + (k * colW) + colW/2).attr("cy", centerY).attr("r", active ? 5 : 2)
                     .attr("class", active ? "upset-dot active" : "upset-dot")
                     .style("fill", active ? "#888" : "#333");
                });
            });
            svg.on("click", (e) => { if(e.target === svg.node()) updateSelection(null); });
        };
        drawViz2();

        window.addEventListener("resize", () => {
            initViz1(); 
            drawViz2(); 
            drawViz3(); 
            if (currentIndex > -1) {
                 drawViz4(sortedData[currentIndex]);
                 updateSelection(sortedData[currentIndex].school);
            } else {
                 drawViz4(null);
            }
        });

        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('about-modal');
            if (modal && modal.style.display === 'flex') {
                if(e.key === "Escape") modal.style.display = 'none';
                return;
            }
            if (e.key === "Escape") {
                updateSelection(null);
                return;
            }
            if (e.key === 'f' || e.key === 'F') {
                toggleFullScreen();
            }
        });

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { 
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { 
                    document.msExitFullscreen();
                }
            }
        }
    });
</script>
</body>
</html>





